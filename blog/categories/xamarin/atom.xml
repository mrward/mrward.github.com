<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xamarin | Matt Ward]]></title>
  <link href="http://lastexitcode.com/blog/categories/xamarin/atom.xml" rel="self"/>
  <link href="http://lastexitcode.com/"/>
  <updated>2018-05-20T15:19:09+01:00</updated>
  <id>http://lastexitcode.com/</id>
  <author>
    <name><![CDATA[Matt Ward]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[.NET Core Support in Visual Studio for Mac 7.5]]></title>
    <link href="http://lastexitcode.com/blog/2018/05/20/NetCoreSupportInVisualStudioMac7-5/"/>
    <updated>2018-05-20T09:00:00+01:00</updated>
    <id>http://lastexitcode.com/blog/2018/05/20/NetCoreSupportInVisualStudioMac7-5</id>
    <content type="html"><![CDATA[<h2>New Features</h2>

<ul>
<li>.NET Core 2.1 SDK support

<ul>
<li>.NET Core 2.1 SDK project templates</li>
<li>HTTPS development certificate support</li>
<li>.NET Core global tools added to PATH on startup</li>
</ul>
</li>
<li>.NET Core location can now be configured</li>
<li>Xamarin.Forms project templates now use .NET Standard projects</li>
<li>Performance improvements when using projects with many files</li>
<li>.NET Core templating engine has been updated</li>
<li>Improved support for Xamarin.Forms</li>
<li>Item templates are now supported with the .NET Core templating engine</li>
</ul>


<p>More information on all the new features and changes in <a href="https://www.visualstudio.com/vs/visual-studio-mac/">Visual Studio for Mac 7.5</a> can be found in the
<a href="https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-mac-relnotes#-visual-studio-2017-for-mac-version-75-release-notes">release notes</a>.</p>

<h2>.NET Core 2.1 SDK support</h2>

<p>Visual Studio for Mac 7.5 includes support for the .NET Core 2.1 SDK which is currently
available as a <a href="https://blogs.msdn.microsoft.com/dotnet/2018/05/07/announcing-net-core-2-1-rc-1/">release candidate</a>. The following
sections will look into the support provided by Visual Studio for Mac 7.5 for the .NET Core 2.1 SDK.</p>

<h3>.NET Core 2.1 SDK project templates</h3>

<p>If .NET Core 2.1.300 SDK is installed then the .NET Core 2.1 project templates
will be available in the New Project dialog.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/NewProjectDialogNetCore21TargetFramework.png" title="&lsquo;New Project dialog &ndash; .NET Core 2.1 target framework option&rsquo; &lsquo;New Project dialog &ndash; .NET Core 2.1 target framework option&rsquo;" ></p>

<p>The .NET Core 2.1 project templates are not included with Visual Studio for Mac and
will be searched for in the 2.1.300 SDK templates directory.</p>

<pre><code>/usr/local/share/dotnet/sdk/2.1.300-rc1-008673/Templates/
</code></pre>

<p>The project templates for .NET Core 2.0 and 1.1 are currently still being shipped
with Visual Studio for Mac.</p>

<h3>HTTPS development certificate support</h3>

<p>ASP.NET Core 2.1 projects use HTTPS by default. In order to be able to run
ASP.NET Core 2.1 projects with HTTPS a development certificate needs to be installed.
Visual Studio for Mac will detect if the development certificate is missing
and offer to install it when you run an ASP.NET Core 2.1 project that uses
HTTPS.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/HttpsDevCertificateNotInstalledMessage.png" title="&lsquo;HTTPS development certificate not installed message&rsquo; &lsquo;HTTPS development certificate not installed message&rsquo;" ></p>

<p>Visual Studio for Mac will use the dotnet dev-certs tool to check if the
HTTPS development certificate is installed and trusted.</p>

<pre><code>dotnet dev-certs https --trust --check
</code></pre>

<p>Installing the HTTPS certificate requires administrator privileges so you may be
prompted for your username and password after clicking the Yes button. Currently
the prompt for credentials shows <strong>mono-sgen64 wants to make changes</strong>. In the future this will show a
custom message indicating that the credentials are required to install the HTTPS development certificate.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/MonoSGenAdminPrompt.png" title="&lsquo;Mono sgen administrator dialog prompt&rsquo; &lsquo;Mono sgen administrator dialog prompt&rsquo;" ></p>

<p>After entering your credentials the following command is run as administrator.</p>

<pre><code>dotnet dev-certs https --trust
</code></pre>

<p>After the certificate is installed the ASP.NET Core 2.1 project will be
opened in the default browser using HTTPS.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/AspNetCoreProjectInChromeUsingHttps.png" title="&lsquo;ASP.NET Core 2.1 project open in browser using HTTPS&rsquo; &lsquo;ASP.NET Core 2.1 project open in browser using HTTPS&rsquo;" ></p>

<p>Running <strong>dotnet dev-certs https &mdash;trust</strong> to install and trust the certificate needs to be
done with administrator privileges with the user id 0. To do this Visual Studio for Mac
does the following:</p>

<ol>
<li>Launches a separate custom console app.</li>
<li>The console app uses the AuthorizationExecuteWithPrivileges Mac
API provided by Xamarin.Mac to launch itself as again as administrator.
It is not possible to run dotnet as administrator initially since it requires the user id to be
set to 0, which is what happens when you use <strong>sudo dotnet</strong>, and this can only be done
when running with administrator privileges. So the console app is launched again but this
time with administrator privileges.</li>
<li>The console app, now being run with administrator privileges, will use setuid to set the
current user id to 0.</li>
<li>The console app then runs <strong>dotnet dev-certs https &mdash;trust</strong> which
will install and trust the HTTPS development certificate.</li>
</ol>


<p>The <strong>dotnet dev-certs https &mdash;trust</strong> command will add two localhost certificates. You
can see these by opening the Keychain Access application and searching for
localhost.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/LocalhostCertificateInKeychain.png" title="&lsquo;localhost certificate created by dotnet dev-certs in Keychain Access application&rsquo; &lsquo;localhost certificate created by dotnet dev-certs in Keychain Access application&rsquo;" ></p>

<p>If the HTTPS development certificate is found to be valid and
trusted then this will be remembered for the current Visual Studio for Mac
session and a check will not be run again during the current session.</p>

<h3>.NET Core global tools added to path on startup</h3>

<p>The .NET Core SDK 2.1 supports installing global tools. These tools are .NET Core console apps
that are available as NuGet packages and can be installed and used from the command line.
To be able to use these tools with the dotnet command line the <strong>~/.dotnet/tools</strong>
directory needs to be added to the PATH environment variable. The path to
these global tools is now added to Visual Studio&rsquo;s PATH environment variable
when it starts.</p>

<h3>Prompt to install .NET Core 2.1 SDK if not installed</h3>

<p>If a .NET Core 2.1 project is opened and .NET Core 2.1.300 SDK is not
installed then a dialog will be shown allowing the SDK to
be downloaded. The project in the Solution window will show an error
icon indicating that the .NET Core 2.1 SDK is not
installed.</p>

<h3>Launching a browser when running an ASP.NET Core 2.1 project</h3>

<p>The .NET Core SDK 2.1 project templates for ASP.NET Core
specify the https and http urls in the launchSettings.json file
by using the applicationUrl property.</p>

<pre><code>    "MyAspNetCore21Project": {
        "commandName": "Project",
        "launchBrowser": true,
        "applicationUrl": "https://localhost:5001;http://localhost:5000",
        "environmentVariables": {
            "ASPNETCORE_ENVIRONMENT": "Development"
        }
    }
</code></pre>

<p>With earlier .NET Core 2.1 preview SDKs this was defined in the
ASPNETCORE_URLS environment variable. The full applicationUrl
property was used unmodified when running the ASP.NET Core 2.1 project and
resulted in an invalid url being used causing the AspNetCoreExecutionHandler to log a warning
and not opening the browser. Now the first url in the applicationUrl
is used if there are multiple urls.</p>

<h3>Support ASPNETCORE_URLS when launching the browser</h3>

<p>If the launchSettings.json does not define an applicationUrl then
Visual Studio for Mac will fallback to checking the environment variable defined
for ASPNETCORE_URLS in the launchSettings.json file and will use the first url
found there. This url will be used to launch the browser when running the project.</p>

<p>An example launchSettings.json that was used in the .NET Core 2.1 preview SDKs
is shown below.</p>

<pre><code>"MyProject": {
  "commandName": "Project",
  "launchBrowser": true,
  "environmentVariables": {
    "ASPNETCORE_ENVIRONMENT": "Development",
    "ASPNETCORE_URLS": "https://localhost:5001;http://localhost:5000"
  }
}
</code></pre>

<p>Compared with the .NET Core SDK 2.0.</p>

<pre><code>"MyProject": {
  "commandName": "Project",
  "launchBrowser": true,
  "environmentVariables": {
    "ASPNETCORE_ENVIRONMENT": "Development"
  },
  "applicationUrl": "http://localhost:5000/"
}
</code></pre>

<h2>Allow .NET Core location to be configured</h2>

<p>In Preferences there is now a Projects &ndash; SDK Locations &ndash; .NET Core
section that can be used to configure the location of the .NET Core
command line tool (dotnet).</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/NetCoreLocationConfiguration.png" title="&lsquo;.NET Core location configured in preferences&rsquo; &lsquo;.NET Core location configured in preferneces&rsquo;" ></p>

<p>This can be used to configure Visual Studio for Mac to use a
.NET Core SDK that is not installed in the default location. After this is
changed the MSBuild engine hosts are recycled and all .NET Core projects
are re-evaluated to ensure the new locations of any MSBuild targets
are used.</p>

<p>If the location is invalid, or no runtimes or SDKs can be found at the configured
location, a Not found error will be displayed.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/NetCoreLocationInvalidPath.png" title="&lsquo;Invalid .NET Core location path specified in preferences&rsquo; &lsquo;Invalid .NET Core location path specified in preferences&rsquo;" ></p>

<h2>Xamarin.Forms Project Templates now include .NET Standard projects</h2>

<p>The Xamarin.Forms project templates, Blank Forms App and Forms App, will now
create a .NET Standard 2.0 project instead of a Portable Class Library (PCL) project
if .NET Standard is selected in the New Project dialog.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/NewProjectDialogFormsNetStandard.png" title="&lsquo;New Project dialog &ndash; Blank Forms &ndash; .NET Standard option&rsquo; &lsquo;New Project dialog &ndash; Blank Forms &ndash; .NET Standard option&rsquo;" ></p>

<p>The Xamarin.Forms Class Library project template now creates a .NET Standard 2.0 project instead of
a Portable Class Library project.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-5/NewProjectDialogXamarinFormsLibraryProject.png" title="&lsquo;New Project dialog &ndash; Xamarin.Forms Class Library project&rsquo; &lsquo;New Project dialog &ndash; Xamarin.Forms Class Library project&rsquo;" ></p>

<h2>Prevent .xaml.cs file from being renamed in a .NET Core project</h2>

<p>The Xamarin.Forms NuGet package has an MSBuild .targets file that is imported
after the project items are defined. This .targets file overrides
the DependentUpon property for all .xaml.cs files. This means that renaming the
.xaml.cs file to be different to the .xaml file is not supported.
To prevent this the Rename menu is now disabled in the Solution
window for .xaml.cs files if they depend on a .xaml file.</p>

<h2>Exclude None build action for XAML files in .NET Core projects</h2>

<p>Recent versions of Xamarin.Forms NuGet packages exclude all .xaml files from the
default None file wildcard defined by the .NET Core SDK. This exclusion is
done in a .targets file which is applied after the items in the project
file have been added. This means that a .NET Standard project should not use
None items for .xaml files since they will be removed. To avoid this problem
the None build action is excluded from the list of build actions for .xaml files.
This list of build actions is available when right
clicking the file in the Solution window and in the Properties window when
the file is selected.</p>

<h2>Dependent files now renamed on renaming parent file in the Solution window</h2>

<p>When a file is renamed in the Solution window the dependent files will
also be renamed if they start with the same name as the parent file.
This avoids problems with XAML files since a different name for the .xaml file
and the associated .xaml.cs file is not supported.</p>

<h2>Improve project load times for projects with many files</h2>

<p>Opening a .NET Core project that contained many files that
were not excluded, such as a .NET Core console project that has a
node_modules directory, could take a long time to load.</p>

<p>Some performance improvements have been made to speed up the
loading of .NET Core projects. For a .NET Core console project that had a node_modules
directory containing around 17000 files the initial project load time which
was taking around 70-80 seconds and now it takes around 20 seconds. Visual Studio 2017 on
Windows takes around 15-20 seconds to load the same project before
it is visible in the Solution Explorer window.</p>

<p>The performance improvements include:</p>

<ol>
<li>Adding a faster project item lookup used when finding an existing
project item on loading the project.</li>
<li>Updating the existing project items is now faster avoiding iterating
over the existing items.</li>
<li>Evaluating MSBuild items is now only done when evaluating properties.
Previously this was done when evaluating project configurations and run configurations.
This would result in
files and directories being searched multiple times when looking
wildcard matches on loading the project. Now the files
and directories are searched once during the initial project load.</li>
</ol>


<h2>.NET Core templating engine updated</h2>

<p>Updated the .NET Core templating to version 1.0.0-beta3-20171117-314. This new
version of the .NET Core templating engine fixes the following problems:</p>

<ol>
<li>Templates that use files with @ character in their names being generated with the
@ symbol encoded.</li>
<li>Templates that use the Guid macro and did not specify a format
would cause the template generation to fail. An exception was thrown
since the format was not defined. Now
if the format is not defined the default format is used.</li>
</ol>


<h2>Report template creation failures when using the .NET Core templating engine</h2>

<p>To help diagnose problems with project and item templates that use the
.NET Core templating engine more detailed information about the failure is now logged
in the IDE log.</p>

<h2>Support item templates with the new templating engine</h2>

<p>Item templates that use the .NET Core
templating engine can be defined through a new extension point.</p>

<pre><code>&lt;Extension path="/MonoDevelop/Ide/ItemTemplates"&gt;
        &lt;Template
                id="Azure.Function.CSharp.BlobTrigger"
                _overrideName="Blob Trigger"
                path="Templates/Azure.Functions.Templates.nupkg" /&gt;
&lt;/Extension&gt;
</code></pre>

<p>Item templates are not currently supported in the New File dialog however there
is an API that can be used by extensions to create files from these templates.
This is currently used when adding a new Azure Function to a project.</p>

<h2>Bug Fixes</h2>

<p><strong>Missing child package dependencies in Solution window</strong></p>

<p>After creating a new ASP.NET Core project sometimes the package dependencies
shown in the Solution window under the SDK folder and the NuGet folder
could not be expanded to view the child dependencies.</p>

<p>The problem was that if the call to get the package dependencies
using MSBuild was cancelled this would result an empty list of depenencies
being cached. Since no package dependencies were returned the Solution window
would fallback to showing the package dependencies that were listed in the
project and a default top level SDK package dependency.</p>

<p><strong>MSBuild wildcards being expanded on saving a project</strong></p>

<p>Saving a project with a file wildcard that had a Link with
MSBuild item metadata, as shown below, would result in the wildcard
being removed and replaced with MSBuild items for each file included
by the wildcard.</p>

<pre><code>&lt;Compile Include="**\*.cs" Exclude="obj\**"&gt;
  &lt;Link&gt;%(RecursiveDir)%(Filename).cs&lt;/Link&gt;
&lt;/Compile&gt;
</code></pre>

<p>The problem was that the evaluated Link property value was being
compared with the unevaluated value, which did not match, resulting
in the wildcard being replaced with individual MSBuild items for
each file. Now if the property value contains a % character a comparison is
made against the evaluated value when checking if the project item
has changed.</p>

<p><strong>MSBuild items added for wildcards with link metadata on saving project</strong></p>

<p>A project containing the following MSBuild file wildcards would have
extra MSBuild items added when the project file was saved.</p>

<pre><code>&lt;ItemGroup&gt;
  &lt;Compile Include="..\**\*.cs"&gt;
    &lt;Link&gt;%(RecursiveDir)%(Filename)%(Extension)&lt;/Link&gt;
  &lt;/Compile&gt;
&lt;/ItemGroup&gt;
</code></pre>

<p>On saving the project Compile update items would be added for each
file included by the file wildcard.</p>

<pre><code>&lt;ItemGroup&gt;
  &lt;Compile Update="..\Test\Class1.cs"&gt;
    &lt;Link&gt;Class1.cs&lt;/Link&gt;
  &lt;/Compile&gt;
&lt;/ItemGroup&gt;
</code></pre>

<p>This problem is similar to the previous problem where the evaluated Link value was being
compared with the unevaluated value, which did not match, resulting
MSBuild update items being added to the project when it was saved. Now if the property
value contains a % character a comparison is made against the evaluated value when checking if
the project item has changed.</p>

<p><strong>TargetFramework changed on saving project</strong></p>

<p>Adding a file to an SDK style project that targeted Tizen 4.0 would
result in the TargetFramework changing from <strong>tizen40</strong> to <strong>tizen4.0</strong>.
Now the original framework identifier name is not modified and if
the version of the framework changes then the version will be
dotted or contain only numbers based on the format that was originally used
in the project file.</p>

<p><strong>ASP.NET Core file templates modifying project file</strong></p>

<p>Adding a new .cshtml file from a file template to an ASP.NET Core
project would modify the project file when it should not have been
modified. The problem was the files were added as None items whilst
.cshtml are Content items. The project file would contain the
following after adding a new cshtml file from a template:</p>

<pre><code>&lt;ItemGroup&gt;
  &lt;Content Remove="Views\Index.cshtml" /&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
  &lt;None Include="Views\Index.cshtml" /&gt;
&lt;/ItemGroup&gt;
</code></pre>

<p>Another problem was that the Razor Page with view model file
template specifies a DependentUpon property so this was added to the
project file. This would result in the .cshtml and .cs files being nested whilst
the other .cshtml and .cs files created with the initial ASP.NET
Core project template were not nested. The project file would include
the following:</p>

<pre><code>&lt;ItemGroup&gt;
  &lt;Compile Update="Views\Index.cshtml.cs"&gt;
    &lt;DependentUpon&gt;Index.cshtml&lt;/DependentUpon&gt;
  &lt;/Compile&gt;
&lt;/ItemGroup&gt;
</code></pre>

<p>The .NET Core SDK does not indicate that .cshtml and .cs
files are dependent on each other so they are not currently nested
in the Solution window. New .cshtml files created from these updated
file templates will now not be nested in Solution window.</p>

<p><strong>XAML files not nested after editing project file in editor</strong></p>

<p>Adding a new content page with xaml to a .NET Standard project,
then excluding the files from the project, but not deleting it,
then editing the project file and commenting out the MSBuild remove
items, would then result in the xaml files not being nested in the
Solution window. The problem was that the MSBuild update item
for the .xaml.cs file, defined by the Xamarin.Forms default msbuild
items, was being removed from the MSBuild project in
memory. This MSBuild update item had the DependsOn property defined
so this information was lost on reloading the project. Now a check
is to made to ensure only update items that exist in the original
project file are removed.</p>

<p><strong>MSBuild item added for XAML file copied to a .NET Standard project</strong></p>

<p>When copying a .xaml file from a Portable Class Library project to a .NET Standard project
an MSBuild include item for the file would be added if the .xaml file did
not have the default metadata properties defined by Xamarin.Forms.
Now .NET Core projects opt-in to supporting items not being excluded if they
are missing MSBuild item metadata
which prevents an MSBuild include item added for the .xaml file.</p>

<p><strong>Duplicate XAML file build error when copying file to a .NET Standard project</strong></p>

<p>Copying a .xaml file from a Portable Class Library project to a .NET Standard project
would result an MSBuild item for the .xaml file to the project causing it to not
build due to a duplicate .xaml file.</p>

<p>Now when a xaml file is copied into a .NET Standard project, and it is missing
properties that are included in by an update wildcard,
an MSBuild item will not be added to the project.</p>

<p><strong>MSBuild remove item not added for .xaml.cs file</strong></p>

<p>With a .NET Core project, containing a single .xaml file and a
dependent .xaml.cs file, removing but not deleting the .xaml file
from the Solution window would not add an MSBuild remove item for
the .xaml.cs file even though it was removed from the Solution window.</p>

<p>The problem was that the Xamarin.Forms NuGet package includes a
Compile update item and only this was being considered when saving
the project file. The default file wildcard, that includes all .cs files,
provided by the .NET Core SDK was not considered. Only the last MSBuild item
associated with the .xaml.cs file was being considered. If there was another .cs
file in the project then the MSBuild remove item was added correctly. To avoid this
all MSBuild items associated with a project item are now considered.</p>

<p><strong>MSBuild remove item not removed on adding XAML file to project</strong></p>

<p>When an .xaml file was removed but not deleted, and Xamarin.Forms 2.5
used, which has default MSBuild items defined, on adding the .xaml
file back again to the project the EmbeddedResource
remove item was not removed from the project.</p>

<p>The problem was that the .xaml file was being added as a None item
since by default there is no build action specified for .xaml files.</p>

<p>Another problem was that the MSBuild remove
items, defined by Xamarin.Forms that remove all .xaml files from the default None
included by the .NET Core SDK, were being ignored since the file wildcards were not
found.</p>

<p>Also an msbuild item is no longer added for an existing xaml file when it is
added to the project. The Xamarin.Forms default msbuild items
for .xaml files have extra metadata which were not being added to
the file when it was added to the project from the file system.</p>

<p><strong>Update item added on renaming xaml.cs file</strong></p>

<p>When the .xaml and .xaml.cs file were renamed at the same time an
MSBuild update item was added for the .xaml.cs file even though the Xamarin
Forms NuGet package has a default MSBuild item that was the same as
the generated MSBuild update item.</p>

<p><strong>Argument null exception logged on opening .NET Core project</strong></p>

<p>Opening a .NET Core project would sometimes log an unhandled
ArgumentNullException. A file created event was sometimes raised before
the project had finished loading and could result in
a null set of items being used when checking if the
new file should be added to the project. This is now handled. The files being
created on project load are typically in the obj folder and would be
ignored by the default file wildcards.</p>

<pre><code>An unhandled exception has occured. Terminating Visual Studio? False
System.ArgumentNullException: Value cannot be null.
Parameter name: source
  at System.Linq.Enumerable.Where[TSource]
  in corefx/src/System.Linq/src/System/Linq/Where.cs:42
  at MonoDevelop.Projects.Project.OnFileCreatedExternally
in src/core/MonoDevelop.Core/MonoDevelop.Projects/Project.cs:4041
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NuGet Support in Visual Studio for Mac 7.5]]></title>
    <link href="http://lastexitcode.com/blog/2018/05/19/NuGetSupportInVisualStudioMac7-5/"/>
    <updated>2018-05-19T15:30:00+01:00</updated>
    <id>http://lastexitcode.com/blog/2018/05/19/NuGetSupportInVisualStudioMac7-5</id>
    <content type="html"><![CDATA[<h2>Changes</h2>

<ul>
<li> Support installing NuGet packages with item templates</li>
<li> Fixed generated NuGet package files not available for code completion</li>
<li> Fixed incorrect Android target framework used when the project has Package References</li>
<li> Fixed build errors after creating a new Android project with NuGet packages</li>
<li> Missing package dependencies in Solution window</li>
</ul>


<p>More information on all the new features and changes in <a href="https://www.visualstudio.com/vs/visual-studio-mac/">Visual Studio for Mac 7.5</a>
can be found in the <a href="https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-mac-relnotes#-visual-studio-2017-for-mac-version-75-release-notes">release notes</a>.</p>

<h2>Support installing NuGet packages with item templates</h2>

<p>Initial support for creating new files from item templates that use
the .NET Core templating engine has been added. This is currently used
by the Azure Functions support in Visual Studio for Mac when a new Azure
Function is added to the project. Currently the New File dialog does not
have support for showing these templates but there is an API that can
be used by extensions to create files from these templates.</p>

<p>The item templates can define post actions that indicate that a NuGet
package is needed. These post actions are read and the NuGet
package will be installed into the project by Visual Studio for Mac.</p>

<pre><code>"postActions": [
  {
    "Description": "Adding Reference to Microsoft.Azure.WebJobs.Extensions.DocumentDB Nuget package",
    "ActionId": "B17581D1-C5C9-4489-8F0A-004BE667B814",
    "ContinueOnError": "true",
    "ManualInstructions": [],
    "args": {
      "referenceType": "package",
      "reference": "Microsoft.Azure.WebJobs.Extensions.DocumentDB",
      "version": "1.2.0",
      "projectFileExtensions": ".csproj"
    }
  }
</code></pre>

<h2>Bug Fixes</h2>

<p><strong>Generated NuGet package files not available for code completion</strong></p>

<p>On installing a NuGet package such as Refit, which extends the
CoreCompileDependsOn to generate a C# file, the generated file would
not be available for code completion until the solution was closed
and re-opened again.</p>

<p>Below is a section of the refit.targets file used by the Refit NuGet package.</p>

<pre><code>&lt;PropertyGroup&gt;
  &lt;CoreCompileDependsOn&gt;
    $(CoreCompileDependsOn);
    GenerateRefitStubs;
  &lt;/CoreCompileDependsOn&gt;
&lt;/PropertyGroup&gt;

&lt;Target Name="GenerateRefitStubs" BeforeTargets="CoreCompile"&gt;

  &lt;Error Condition="'$(MSBuildRuntimeType)' == 'Core' and '$(RefitMinCoreVersionRequired)' &gt; '$(RefitNetCoreAppVersion)' "
       Text="Refit requires at least the .NET Core SDK v2.0 to run with 'dotnet build'"
       ContinueOnError="false"
       /&gt;

  &lt;GenerateStubsTask SourceFiles="@(Compile)" BaseDirectory="$(MSBuildProjectDirectory)"   OutputFile="$(IntermediateOutputPath)\RefitStubs.g.cs" /&gt;

  &lt;Message Text="Processed Refit Stubs" /&gt;      

  &lt;ItemGroup Condition="Exists('$(IntermediateOutputPath)\RefitStubs.g.cs')"&gt;
    &lt;Compile Include="$(IntermediateOutputPath)\RefitStubs.g.cs" /&gt;
  &lt;/ItemGroup&gt;    
&lt;/Target&gt;
</code></pre>

<p>The CoreCompileDependsOn property is re-defined so the GenerateRefitsStubs MSBuild
target will be run. This creates a new RefitStubs.g.cs file which is included in the
project by the Compile MSBuild item.</p>

<p>The problem was that the result of running the
targets that are defined by the CoreCompileDependsOn property are cached by Visual
Studio for Mac.
When Refit is installed the cached result was still being returned so the
generated C# file was not available for code completion. To fix this the
project is now re-evaluated before getting the CoreCompileDependsOn property
if an MSBuild import has been added or removed. Note that projects that use
Package References were unaffected. Only projects that use a packages.config
file were affected.</p>

<p><strong>Incorrect Android target framework used when the project has Package References</strong></p>

<p>Configuring an Android project so it uses the latest Android framework
could result in the wrong target framework being used when building if the
project used Package References. This would result in a build error
similar to:</p>

<pre><code>Error: Your project is not referencing the "MonoAndroid,Version=v7.1" framework. 
Add a reference to "MonoAndroid,Version=v7.1" in the "frameworks" section of your 
project.json, and then re-run NuGet restore
</code></pre>

<p>The problem was that the wrong target framework was being used in the
project.assets.json. Running a NuGet restore was
a workaround for the problem.</p>

<p>Now when the target framework version in project options is changed, and
the project uses Package References, a NuGet restore is run after the
project file is saved. This ensures the Package References work with
the new target framework. This also re-generates the project.assets.json file
so the build will use the correct references.</p>

<p>Another problem here was that configuring the Android to use the latest
target framework would not result in the target framework being changed
in the project model stored in memory.
This could also result in the project.assets.json file being out of
sync with the Android project&rsquo;s target framework.</p>

<p><strong>Build errors after creating a new Android project with NuGet packages</strong></p>

<p>Creating a new Android project that installed NuGet packages as it was created
would sometimes result in build errors that could be fixed by closing and
re-opening the solution. An example build error is shown below.</p>

<pre><code>Resources/values/styles.xml : error APT0000: 1: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light.DarkActionBar'.
Resources/values/styles.xml : error APT0000: 2: error: Error: No resource found that matches the given   name: attr 'colorAccent'.
Resources/values/styles.xml : error APT0000: 1: error: Error: No resource found that matches the given name: attr 'colorPrimary'.
Resources/values/styles.xml : error APT0000: 1: error: Error: No resource found that matches the given name: attr 'colorPrimaryDark'.
Resources/values/styles.xml : error APT0000: 1: error: Error: No resource found that matches the given name: attr 'windowActionBar'.
Resources/values/styles.xml : error APT0000: 3: error: Error: No resource found that matches the given name: attr 'windowActionModeOverlay'.
Resources/values/styles.xml : error APT0000: 1: error: Error: No resource found that matches the given name: attr 'windowNoTitle'.
Resources/values/styles.xml : error APT0000: 3: error: Error retrieving parent for item: No resource found that matches the given name 'Theme.AppCompat.Light.Dialog'.
Resources/values/styles.xml : error APT0000: 3: error: Error: No resource found that matches the given name: attr 'colorAccent'.
</code></pre>

<p>The build errors varied but in each case the error was caused by a
missing reference to an assembly from one of the Android Support NuGet packages installed
when the project was created. The project file created would have
the correct reference information but Visual Studio for Mac was
building an old version of the project.</p>

<p>If the project was modified in memory when a build is requested this
results in the unsaved project xml being given to the remote MSBuild
host. In some cases this project xml was not being cleared and would
result in an out of date project xml being used when building. This
could occur if the MSBuild host did not have any projects
loaded at the time when an attempt was made to unload the project from
the host. Now the unsaved project xml is removed in all cases when the
project is unloaded from the MSBuild host.</p>

<p><strong>Missing package dependencies in Solution window</strong></p>

<p>After creating a new ASP.NET Core project sometimes the package dependencies
shown in the Solution window under the SDK folder and the NuGet folder
could not be expanded to view the child dependencies.</p>

<p>The problem was that if the call to get the package dependencies
using MSBuild was cancelled this would result an empty list of depenencies
being cached. Since no package dependencies were returned the Solution window
would fallback to showing the package dependencies that were listed in the
project and a default top level SDK package dependency.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Server Protocol support in Visual Studio for Mac 7.4]]></title>
    <link href="http://lastexitcode.com/blog/2018/03/18/LanguageServerSupportInVisualStudioMac7-4/"/>
    <updated>2018-03-18T12:30:00+00:00</updated>
    <id>http://lastexitcode.com/blog/2018/03/18/LanguageServerSupportInVisualStudioMac7-4</id>
    <content type="html"><![CDATA[<p>A preview of support for the <a href="https://github.com/Microsoft/language-server-protocol">Language Server Protocol</a>
is now available for Visual Studio for Mac 7.4 as a separate extension.</p>

<p><img src="/images/blog/LanguageServerSupportInVisualStudioMac/DockerLanguageServerClient.gif" title="&lsquo;Docker Language Server client being used in Visual Studio for Mac&rsquo; &lsquo;Docker Language Server client being used in Visual Studio for Mac&rsquo;" ></p>

<p>A Language Server can provide support for programming language features such as:</p>

<ul>
<li>Code completion</li>
<li>Find references</li>
<li>Go to definition</li>
<li>Quick fixes</li>
<li>Method signature help</li>
<li>Errors and warnings diagnostics</li>
<li>Documentation on hover</li>
<li>Document formatting</li>
<li>Rename refactoring</li>
</ul>


<p>The <a href="https://github.com/Microsoft/language-server-protocol">Language Server Protocol</a> provides a way for a
client application, such as Visual Studio for Mac, to communicate with the Language Server in order to
use the programming language features it supports.</p>

<p><a href="https://code.visualstudio.com">Visual Studio Code</a> supports the
<a href="https://code.visualstudio.com/blogs/2016/06/27/common-language-protocol">Language Server Protocol</a>.</p>

<p>A preview of <a href="https://blogs.msdn.microsoft.com/visualstudio/2017/11/21/announcing-language-server-protocol-preview-release/">Language Server Protocol support in Visual Studio 2017 on Windows</a>
has also been announced.</p>

<p>Currently there is no support for debugging. Whilst there is a
<a href="https://code.visualstudio.com/docs/extensionAPI/api-debugging">debugging protocol</a> support
for this is not currently available in Visual Studio for Mac.</p>

<p>The Language Server Protocol does not provide any support for compiling the code. This would need
to be provided by the extension that implements the language client.</p>

<p>More detailed information about the Language Server Protocol can be found on the
<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol site</a>.</p>

<p>The <strong>Creating a Language Client</strong> section below will take a more detailed look at how to implement
a custom Language Server Client extension in Visual Studio for Mac.</p>

<h2>Supports</h2>

<ul>
<li>MonoDevelop or Visual Studio Mac 7.4 or later.</li>
</ul>


<h2>Source Code</h2>

<ul>
<li><a href="https://github.com/mrward/monodevelop-language-server-addin">Language Server Client extension for Visual Studio for Mac and MonoDevelop</a></li>
</ul>


<h2>Installation</h2>

<p>The Language Server Client extension is available to download from <a href="https://github.com/mrward/monodevelop-language-server-addin/releases/download/0.1-monodevelop-7.4/MonoDevelop.LanguageServer.Client_0.1.mpack">GitHub</a>.</p>

<p>To install the extension open the Extensions Manager by selecting Extensions&hellip; from the main menu. Click the Install from file button. Select the .mpack file and then click the Open button.</p>

<p>The extension is also available in the Extensions Manager from the
<a href="http://addins.monodevelop.com/Project/Index/307">Visual Studio Extension Repository (Beta channel)</a>.</p>

<h2>Creating a Language Client</h2>

<p>The API provided by the Language Server Client extension follows the <a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/adding-an-lsp-extension">API defined by the
Language Server Protocol extension used by Visual Studio on Windows</a> as
closely as possible.</p>

<p>More detailed documentation on the <a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol">Language Server Client API</a> provided
by Visual Studio on Windows is available from the <a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol">Microsoft docs site</a>.</p>

<h3>Prerequisites</h3>

<p>The <a href="https://github.com/mrward/monodevelop-language-server-addin">Language Server Client Extension</a> for
Visual Studio for Mac should be installed.</p>

<p>Also ensure you have the <a href="https://github.com/mhutch/MonoDevelop.AddinMaker">Addin Maker extension installed</a>.
This can be installed by selecting Extensions&hellip; from the main menu top open the Extensions Manager.
Select the Gallery tab and use the text box at the top right to search for the Addin Maker extension.</p>

<p><img src="/images/blog/LanguageServerSupportInVisualStudioMac/ExtensionsDialogAddinMaker.png" title="&lsquo;Addin maker selected in Extensions Manager dialog&rsquo; &lsquo;Addin maker selected in Extensions Manager dialog&rsquo;" ></p>

<p>Click the Install button to install the Addin Maker extension.</p>

<p>The Addin Maker will be used to create the language client extension.</p>

<h3>Creating an IDE Extension project</h3>

<p>The starting point is to create an IDE Extension project. This project template is provided by the
Addin Maker extension and is available
from the New Project dialog, in the Other &ndash; IDE Extensions category.</p>

<p><img src="/images/blog/LanguageServerSupportInVisualStudioMac/NewProjectDialogIdeExtension.png" title="&lsquo;IDE Extension project selected in New Project dialog&rsquo; &lsquo;IDE Extension project selected in New Project dialog&rsquo;" ></p>

<p>After creating the IDE Extensions project, expand the Dependencies folder to show the
Extensions folder. Right click the Extensions folder and select Add Addin Reference.</p>

<p><img src="/images/blog/LanguageServerSupportInVisualStudioMac/NewProjectDialogIdeExtension.png" title="&lsquo;IDE Extension project selected in New Project dialog&rsquo; &lsquo;IDE Extension project selected in New Project dialog&rsquo;" ></p>

<p>Find the MonoDevelop.LanguageServer.Client in the Add Extension Reference dialog. Select it to
toggle its check box and then click the Add button to reference it.</p>

<p><img src="/images/blog/LanguageServerSupportInVisualStudioMac/AddExtensionReferenceDialogLanguageServerClient.png" title="&lsquo;Language Server Client extension in Add Extension Reference dialog&rsquo; &lsquo;Language Server Client extension in Add Extension Reference dialog&rsquo;" ></p>

<p>There are three parts to implementing a language client:</p>

<ul>
<li>Enabling <a href="https://github.com/Microsoft/vs-mef">Managed Extensibility Framework (MEF)</a> support</li>
<li>Defining the supported content
types</li>
<li>Implementing the ILanguageClient interface.</li>
</ul>


<p>First we will take a look at enabling MEF support.</p>

<h3>Enabling Managed Extensibility Framework Support</h3>

<p>Registration of the language client with Visual Studio for Mac is done using the <a href="https://github.com/Microsoft/vs-mef">Managed Extensibility Framework (MEF)</a>
which is supported by Visual Studio for Mac.</p>

<p>In order to use MEF in your language client extension you need to indicate to Visual Studio
for Mac that it should scan your extension for dependencies. This can be done in the
extension&rsquo;s .addin.xml file by adding the filename of your assembly.</p>

<p>```</p>

<pre><code>&lt;Extension path="/MonoDevelop/Ide/Composition"&gt;
    &lt;Assembly file="MockLanguageExtension.dll" /&gt;
&lt;/Extension&gt;
</code></pre>

<p>```</p>

<h3>Content Type Definition</h3>

<p>Your language client needs to indicate what files are supported. This is done by defining
a content type definition.</p>

<p>```
using System.ComponentModel.Composition;
using Microsoft.VisualStudio.LanguageServer.Client;
using Microsoft.VisualStudio.Utilities;</p>

<p>namespace MockLanguageExtension
{</p>

<pre><code>#pragma warning disable CS0649 // Field is never assigned to.

public class FooContentDefinition
{
    [Export]
    [Name("foo")]
    [BaseDefinition(CodeRemoteContentDefinition.CodeRemoteContentTypeName)]
    internal static ContentTypeDefinition FooContentTypeDefinition;

    [Export]
    [FileExtension(".foo")]
    [ContentType("foo")]
    internal static FileExtensionToContentTypeDefinition FooFileExtensionDefinition;
}

#pragma warning restore CS0649
</code></pre>

<p>}
```</p>

<p>The above content definition indicates that the .foo file extension is supported by the language client.</p>

<p>You can also define a filename, instead of a file extension, as supported by the language client by using
the FileName attribute instead of the FileExtension attribute.</p>

<p>```</p>

<pre><code>class DockerContentTypeDefinition
{
    [Export]
    [Name("docker")]
    [BaseDefinition(CodeRemoteContentDefinition.CodeRemoteContentTypeName)]
    internal static ContentTypeDefinition contentTypeDefinition;

    [Export]
    [FileName("Dockerfile")]
    [ContentType("docker")]
    internal static FileExtensionToContentTypeDefinition dockerFileDefinition;
}
</code></pre>

<p>```</p>

<p>You will need to add a reference to <strong>System.ComponentModel.Composition</strong> so the <a href="https://msdn.microsoft.com/library/system.componentmodel.composition.exportattribute.aspx">Export attribute</a>
can be used.</p>

<h3>Implementing ILanguageClient</h3>

<p>To integrate the Language Server with Visual Studio for Mac the
<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclient">ILanguageClient interface</a>
needs to be implemented.</p>

<p>```
using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.LanguageServer.Client;
using Microsoft.VisualStudio.Threading;
using Microsoft.VisualStudio.Utilities;</p>

<p>namespace MockLanguageExtension
{</p>

<pre><code>[ContentType("foo")]
[Export(typeof(ILanguageClient))]
public class FooLanguageClient : ILanguageClient
{
    public IEnumerable&lt;string&gt; ConfigurationSections =&gt; null;

    public object InitializationOptions =&gt; null;

    public IEnumerable&lt;string&gt; FilesToWatch =&gt; null;

    public string Name =&gt; "Foo Language Extension";

    public event AsyncEventHandler&lt;EventArgs&gt; StartAsync;
    public event AsyncEventHandler&lt;EventArgs&gt; StopAsync;

    public async Task OnLoadedAsync()
    {
        await StartAsync?.InvokeAsync(this, EventArgs.Empty);
    }

    public Task&lt;Connection&gt; ActivateAsync(CancellationToken token)
    {
        var info = new ProcessStartInfo();
        var programPath = Path.Combine(Path.GetDirectoryName(GetType().Assembly.Location), "server", @"LanguageServer.UI.exe");
        info.FileName = "mono";
        info.Arguments = programPath;
        info.WorkingDirectory = Path.GetDirectoryName(programPath);
        info.UseShellExecute = false;
        info.RedirectStandardInput = true;
        info.RedirectStandardOutput = true;

        var process = new Process();
        process.StartInfo = info;

        Connection connection = null;

        if (process.Start())
        {
            connection = new Connection(process.StandardOutput.BaseStream, process.StandardInput.BaseStream);
        }

        return Task.FromResult(connection);
    }
}
</code></pre>

<p>}
```</p>

<p>The class that implements the ILanguageClient interface needs to indicate it supports
the content types that you have defined, and it also needs to indicate that it implements the
ILanguageClient by using the Export attribute.</p>

<p>```</p>

<pre><code>[ContentType("foo")]
[Export(typeof(ILanguageClient))]
</code></pre>

<p>```
The language client should return a unique description for the ILanguageClient.Name
property.</p>

<p>The two methods that should be implemented are:</p>

<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclient.onloadedasync">OnLoadedAsync</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclient.activateasync">ActivateAsync</a>.</li>
</ul>


<p>OnLoadedAsync is called when Visual Studio for Mac has loaded your extension. To activate
your Language Server you need to call StartAsync. The simplest approach is to call StartAsync
in the OnLoadedAsync method.</p>

<p>```</p>

<pre><code>    public async Task OnLoadedAsync()
    {
        await StartAsync?.InvokeAsync(this, EventArgs.Empty);
    }
</code></pre>

<p>```</p>

<p>Calling StartAsync will cause Visual Studio for Mac to call the ILanguageClient&rsquo;s
ActivateAsync method. This is where you can start the Language Server.</p>

<p>The ActivateAsync method should return a Connection object with the streams that
will be used to communicate with the Language Server. Standard input and output streams
are supported as well as sockets.</p>

<p><code>
var connection = new Connection(process.StandardOutput.BaseStream, process.StandardInput.BaseStream);
</code></p>

<p>The first time you try to run and debug your language client extension you will see an error
in the Application Output similar to:</p>

<p><code>
WARNING: The add-in 'MockLanguageExtension,1.0' could not be updated because some of its
dependencies are missing or not compatible:
  missing: MonoDevelop.LanguageServer.Client,0.1
</code></p>

<p>The Addin Maker runs your language client extension using its own extension database. The
MonoDevelop.LanguageServer.Client extension needs to be installed into this separate database
in order to be able to run and debug your language client extension.</p>

<p>To do this run your language client extension project in Visual Studio for Mac and
install the Language Server Client extension using the Extensions Manager in the instance
of Visual Studio for Mac that is started. Then stop debugging and re-run your extension project
again, and your language client should now be used when you open a supported file.</p>

<p>The content type registration and the ILanguageClient implementation is the minimum
that is needed in order to integrate your Language Server with Visual Studio for Mac.
Now let us take a look at other optional things that can be implemented.</p>

<h3>Receiving Custom Messages</h3>

<p>Your Language Server may support messages that are not part of the standard
Language Server Protocol.</p>

<p>In order to support receiving custom messages the class that implements ILanguageClient should also
implement the
<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclientcustommessage">ILanguageClientCustomMessage</a>
interface. The CustomMessageTarget property should return an object that will receive the messages.</p>

<p>```
public object CustomMessageTarget => new CustomMessageTarget ();
public object MiddleLayer => null;</p>

<p>public Task AttachForCustomMessageAsync(JsonRpc rpc)
{</p>

<pre><code>return Task.CompletedTask;
</code></pre>

<p>}
```</p>

<p>An example CustomMessageTarget class is shown below.</p>

<p>```
using Newtonsoft.Json.Linq;
using StreamJsonRpc;</p>

<p>namespace MockLanguageExtension
{</p>

<pre><code>public class CustomMessageTarget
{
    [JsonRpcMethod("test/customNotification")]
    public void OnCustomNotification(JToken arg)
    {
        // Handle custom message from the Language Server.
    }
}
</code></pre>

<p>}
```</p>

<h3>Sending Custom Messages</h3>

<p>To send custom messages to the Language Server the class that implements the
ILanguageClient interface should also implement the
<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclientcustommessage">ILanguageClientCustomMessage</a> interface.</p>

<p>The AttachForCustomMessageAsync method
should save the JsonRpc object passed and then you can use the JsonRpc object to
send custom messages to the Language Server.</p>

<p>```</p>

<pre><code>    JsonRpc rpc;

    public Task AttachForCustomMessageAsync(JsonRpc rpc)
    {
        this.rpc = rpc;
        return Task.CompletedTask;
    }

    public async Task SendMessageToServer()
    {
        string text = await rpc.InvokeWithParameterObjectAsync&lt;string&gt;("GetText");
        MessageService.ShowMessage("Text from language server:", text);
    }
</code></pre>

<p>```</p>

<h3>Middle Layer</h3>

<p>The ILanguageClientCustomMessage defines a MiddleLayer property. An object returned
from the MiddleLayer property can be used to intercept messages sent to and received
from the Language Server. The MiddleLayer object can implement the following
interfaces:</p>

<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclientcompletionprovider">ILanguageClientCompletionProvider</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclientexecutecommandprovider">ILanguageClientExecuteCommandProvider</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.client.ilanguageclientworkspacesymbolprovider">ILanguageClientWorkspaceSymbolProvider</a></li>
</ul>


<p>```
using System;
using System.Threading.Tasks;
using Microsoft.VisualStudio.LanguageServer.Client;
using Microsoft.VisualStudio.LanguageServer.Protocol;</p>

<p>namespace MockLanguageExtension
{</p>

<pre><code>class MiddleLayerProvider : ILanguageClientCompletionProvider
{
    public Task&lt;object&gt; RequestCompletions(
        TextDocumentPositionParams param,
        Func&lt;TextDocumentPositionParams, Task&lt;object&gt;&gt; sendRequest)
    {
        return sendRequest(param);
    }

    public async Task&lt;CompletionItem&gt; ResolveCompletion(
        CompletionItem item,
        Func&lt;CompletionItem, Task&lt;CompletionItem&gt;&gt; sendRequest)
    {
        return await sendRequest(item);
    }
}
</code></pre>

<p>}
```</p>

<p>Note that currently not all the Language Server messages can be intercepted.</p>

<p>The full source code to the sample Language Server Client Extension created
whilst writing this blog post is available on
<a href="https://github.com/mrward/sample-language-server-client-extension">GitHub</a></p>

<p>There are other examples included with the
<a href="https://github.com/mrward/monodevelop-language-server-addin">Language Server Client extension source code</a>
on GitHub, however these are not standalone and are compiled with the
Language Server Client extension.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.NET Core Support in Visual Studio for Mac 7.4]]></title>
    <link href="http://lastexitcode.com/blog/2018/03/11/NetCoreSupportInVisualStudioMac7-4/"/>
    <updated>2018-03-11T11:00:00+00:00</updated>
    <id>http://lastexitcode.com/blog/2018/03/11/NetCoreSupportInVisualStudioMac7-4</id>
    <content type="html"><![CDATA[<h2>Changes</h2>

<ul>
<li> Solution window detects file system changes outside Visual Studio for Mac</li>
<li> Projects with unknown target frameworks can now be loaded

<ul>
<li><a href="https://oren.codes/2017/08/29/use-all-tfms-with-sdk-style-projects-in-visual-studio-for-mac/">MSBuild SDK Extras</a> is now supported without requiring an extra extension to be installed</li>
<li>Tizen.NET projects are now supported</li>
</ul>
</li>
<li> Fixed xUnit test messages not being displayed</li>
<li> ASP.NET Core minified files are no longer formatted</li>
<li> Support target framework defined in another MSBuild property</li>
<li> Show SDK information before dependencies are restored</li>
<li> Fixed failure to add new file when the default project namespace contains only numbers</li>
<li> Fixed remove item not added for .xaml.cs file</li>
<li> Fixed incorrect project updates when moving a file</li>
</ul>


<p>More information on all the new features and changes in <a href="https://www.visualstudio.com/vs/visual-studio-mac/">Visual Studio for Mac 7.4</a> can be found in the <a href="https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-mac-relnotes#15.6">release notes</a>.</p>

<h2>Solution window detects file system changes</h2>

<p>Files created in the project directory, or a subdirectory,
outside Visual Studio for Mac are now added to the project and
appear in the Solution window automatically.</p>

<p><img src="/images/blog/NetCoreSupportInVisualStudioMac7-4/DotNetCoreProjectFileWatcher.gif" title="&lsquo;File added and removed from command line &ndash; Solution window updated&rsquo; &lsquo;File added and removed from command line &ndash; Solution window updated&rsquo;" ></p>

<p>Deleting project files and directories will remove the files from
the Solution window. The Solution window will also update after
a file or a directory is renamed outside Visual Studio for Mac.</p>

<h2>Allow unknown target framework projects to be loaded</h2>

<p>The target framework of an SDK style project is no longer restricted.
Previously Visual Studio for Mac would fail to load an SDK style
project unless its target framework was .NET Standard, .NET Core App
or .NET Framework.</p>

<p>This allows Tizen projects to be loaded without the error message
&ldquo;Project does not support framework &lsquo;Tizen,Version=v4.0&rsquo;&rdquo; being
displayed. Tizen projects have a Tizen.NET package reference which
imports an MSBuild .props file that defines the Tizen target framework.</p>

<p>The <a href="https://github.com/onovotny/MSBuildSdkExtras">MSBuild.Sdk.Extras</a> NuGet
package is now supported so SDK style projects can use target frameworks
that this NuGet package
supports, such as Xamarin.iOS and MonoAndroid.</p>

<p>On building a project with an unknown target framework, that is
not defined by any used NuGet package references, a build error
that indicates the framework is not supported will occur:</p>

<pre><code>The TargetFramework value 'test1.0' was not recognized.
</code></pre>

<p>NuGet restore will also fail for an unknown target framework with
a message indicating the framework is invalid.</p>

<h2>Bug Fixes</h2>

<p><strong>Fix xUnit test messages not displayed</strong></p>

<p>xUnit tests support an ITestOutputHelper interface which can be
passed to the constructor of the test. This has a WriteLine method
which can be used to output messages whilst running the test. When
this was used the text displayed in Visual Studio for Mac&rsquo;s Test Results
window was:</p>

<pre><code>Microsoft.VisualStudio.TestPlatform.ObjectModel.TestResultMessage
</code></pre>

<p>Now the text from the message is shown in the Tests Results window.</p>

<p><strong>Support target framework defined in another MSBuild property</strong></p>

<p>An SDK style project that defined the <TargetFrameworks> element to
be another MSBuild property would fail to restore.</p>

<p>In the example below the property TheFramework is defined in the
Frameworks.props file.</p>

<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;Import Project="Frameworks.props" /&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFrameworks&gt;$(TheFramework)&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>

<p>The unevaluated MSBuild property value was used and would result in the
NuGet package restore failing.</p>

<p>Now the evaluated property value is used when restoring dependencies.</p>

<p><strong>ASP.NET Core minified files and map files are no longer formatted</strong></p>

<p>On creating a new ASP.NET Core project the minified files were being
re-formatted and were no longer minified. Now the .min.css, .min.js and
.map files are excluded from being re-formatted when a new ASP.NET Core
project is created.</p>

<p><strong>Fixed failure to add a new file when the default project namespace contains only numbers</strong></p>

<p>If a project has a default namespace of &lsquo;1&rsquo; then adding a new C#
file from a template would throw a null reference
exception. The problem was that the sanitized namespace for the project&rsquo;s
default namespace was null.</p>

<p><strong>Show SDK information before dependencies are restored</strong></p>

<p>When a new .NET Core project is created the Dependencies &ndash; SDK folder
would show no items until the NuGet package restore completed. Now
the SDK dependency is shown whilst the dependencies are being restored.</p>

<p><strong>Fixed remove item not added for .xaml.cs file</strong></p>

<p>When a new content page with xaml file was
added and then removed, but not deleted,
a remove item was not added for the .xaml.cs file.</p>

<p><strong>Fixed incorrect project updates when moving a file</strong></p>

<p>Moving a Resource file from one folder to another would not update
the project file correctly. Either the project file would not be
modified or the file would be removed.</p>

<p>One problem was that on moving a clone is taken of the original item
and the associated MSBuild item was copied but was still referring
back to the original location. Another problem was that an incorrect
match was being made when looking for remove items resulting in the
wrong files being removed from the project.</p>

<p><strong>Fixed being unable to use NUnit in a .NET Core test project</strong></p>

<p>The problem was that the NUnit test provider, which supports running NUnit tests
for non .NET Core projects, was finding a PackageReference for NUnit, and then
trying to load the tests for the .NET Core project and failing. To fix this the
NUnit test provider now ignores .NET Core projects so the VS Test provider will
load the tests for the project.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NuGet Support in Visual Studio for Mac 7.4]]></title>
    <link href="http://lastexitcode.com/blog/2018/03/10/NuGetSupportInVisualStudioMac7-4/"/>
    <updated>2018-03-10T12:00:00+00:00</updated>
    <id>http://lastexitcode.com/blog/2018/03/10/NuGetSupportInVisualStudioMac7-4</id>
    <content type="html"><![CDATA[<h2>Changes</h2>

<ul>
<li> Support NuGet RestoreProjectStyle MSBuild Property</li>
<li> .NET Core xUnit tests not displayed if NuGet packages not cached</li>
<li> No tests displayed when project uses a NUnit PackageReference</li>
<li> NuGet MSBuild imports not removed when migrating to project.json</li>
</ul>


<p>More information on all the new features and changes in <a href="https://www.visualstudio.com/vs/visual-studio-mac/">Visual Studio for Mac 7.4</a>
can be found in the <a href="https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-mac-relnotes#15.6">release notes</a>.</p>

<h2>Support RestoreProjectStyle MSBuild property</h2>

<p>If a project sets the RestoreProjectStyle property to be
PackageReference then the project will be restored as though it has
PackageReferences even if it does not have any.</p>

<pre><code>&lt;RestoreProjectStyle&gt;PackageReference&lt;/RestoreProjectStyle&gt;
</code></pre>

<p>This fixes runtime problems when a project references a .NET Standard
project that has PackageReferences. Without the RestoreProjectStyle set
the assemblies from the NuGet packages are not copied to the output
directory and would have to be added to the main project.</p>

<h2>Bug Fixes</h2>

<p><strong>.NET Core xUnit tests not displayed if NuGet packages are not in local NuGet cache</strong></p>

<p>If the NuGet packages that contain the VS Test adapters were not available in
the local machine&rsquo;s NuGet package cache then
the Unit Tests window would not show any tests after the NuGet
packages were restored and the project was compiled.</p>

<p>Visual Studio for Mac would not initially find any test adapter dlls
and would not attempt to discover any tests for the project after the
NuGet packages were downloaded into the NuGet package cache.</p>

<p>Now after the NuGet package restore has completed the check for a
VS Test adapter is now re-run.</p>

<p><strong>No tests displayed when a project uses a NUnit PackageReference</strong></p>

<p>The Unit Tests window would not show any unit tests when a non .NET
Core project contained a NUnit PackageReference. Visual Studio for
Mac was looking for a PackageReference that contained &lsquo;nunit.framework&rsquo;
and was not finding the NUnit NuGet package reference.</p>

<p><strong>NuGet MSBuild imports not removed when migrating to project.json</strong></p>

<p>When a Portable Class Library project was migrated to use a project.json
file the MSBuild imports added by NuGet were not removed. These imports
are added by NuGet into the generated ProjectName.nuget.props and
ProjectName.nuget.targets files on restoring a project.json file.
Leaving the import in the project file would result in the import
being used twice. When a PCL project that used Xamarin.Forms was
migrated to project.json the project would fail to compile with the
error:</p>

<pre><code>Error XF001: Xamarin.Forms targets have been imported multiple times.
Please check your project file and remove the duplicate import(s).
</code></pre>

<p>Now on migrating to project.json the MSBuild imports added by NuGet packages
to the project are removed.</p>

<p><strong>Fix unhandled exception when searching for packages</strong></p>

<p>An unhandled exception was being logged if a package source returned
an error or the package source url was invalid. This was because a
task was not being observed when the package sources were being used.</p>
]]></content>
  </entry>
  
</feed>
